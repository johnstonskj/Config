#!/usr/bin/env bash # -*- mode: sh; eval: (sh-set-shell "bash") -*-

function log_error {
    local command_name="${CMD_EXEC}"
    local line_number=$1; shift
    local message="$*"

    echo "Error: $*"
    printf "\033[31;1m${command_name}:${line_number} [error] ${message}\033[0m\n"
}

function log_trace {
    local command_name="${CMD_EXEC}"
    local line_number=$1; shift
    local message="$*"

    printf "\033[37m${command_name}:${line_number} [trace] ${message}\033[0m\n"
}

CMD_EXEC=$(basename "${0}")
CMD_NAME=stow-away
CMD_DESCRIPTION="dotfile and home directory manager"

ARG_CMD=
ARG_PKG=
ARG_TGT=state
ARG_SRC=()
ARG_DOT_DROP=0
ARG_DOT_PREFIX=0
ARG_DONT_MAKE_PATHS=0
ARG_ADD_GITIGNORE=0

STOW_AWAY_REPOSITORY="${STOW_AWAY_REPOSITORY:-${HOME}/.${CMD_NAME}}"

function usage_title {
    local title=${1^^}
    printf "\033[32;1m${title}\033[0m"
}

function usage_title_low {
    local text="${1}"
    printf "\033[32m${text}\033[0m"
}

function usage_arg {
    local text="${1}"
    printf "\033[33m${text}\033[0m"
}

function usage {
    CMD_UC_EXEC=${CMD_EXEC^^}
    echo
    echo "$(usage_title_low ${CMD_UC_EXEC})(1)"
    echo "    ${CMD_EXEC} - ${CMD_DESCRIPTION}"
    echo
    echo "$(usage_title synopsis)"
    echo "    ${CMD_EXEC} COMMAND [OPTIONS] SOURCE..."
    echo
    echo "$(usage_title commands)"
    echo "    $(usage_arg mv) | $(usage_arg move)         move a file/directory into stow-away"
    echo "    $(usage_arg mk) | $(usage_arg make)         make a file/directory in stow-away"
    echo "    $(usage_arg cd)                cd to the stow-away repository"
    echo
    echo "$(usage_title options)"
    echo "    $(usage_arg -p) | $(usage_arg --package)    name of target package"
    echo "    $(usage_arg -t) | $(usage_arg --target)     one of (bin|cache|config|data|state|runtime)"
    echo "    $(usage_arg -r) | $(usage_arg --repository) specifies the location of the repository path"
    echo "                      '- default taken from \$STOW_AWAY_REPOSITORY"
    echo "    $(usage_arg -d) | $(usage_arg --drop-dot)   removes any leading '.' in the target name"
    echo "    $(usage_arg -D) | $(usage_arg --dot-prefix) replaces any leading '.' with 'dot-' in the target name"
    echo "    $(usage_arg --dont-make-paths) do not create missing target directories"
    echo "    $(usage-arg --add-git-ignore)  create .gitignore files for moved directories"
    echo
    exit ${1}
}

function parse_cmdline {
    while [ $# -gt 0 ]; do
        case "${1}" in
        -h | --help)
            usage 0
            ;;
        cd | mk | make | mv | move)
            if [[ -z "${ARG_CMD}" ]]; then
                if [[ "${1}" == "move" ]]; then
                    ARG_CMD=mv
                elif [[ "${1}" == "make" ]]; then
                    ARG_CMD=mk
                else
                    ARG_CMD=${1}
                fi
            else
                log_error $LINENO "command already specified, previously: ${ARG_CMD}"
                usage 1
            fi
            ;;
        -p | --package)
            ARG_PKG="${2}"
            shift
            ;;
        -d | --drop-dot)
            ARG_DOT_DROP=1
            log_trace $LINENO "setting flag ARG_DOT_DROP"
            ;;
        -D | --dot-prefix)
            ARG_DOT_PREFIX=1
            log_trace $LINENO "setting flag ARG_DOT_PREFIX"
            ;;
        --dont-make-paths)
            ARG_DONT_MAKE_PATHS=1
            log_trace $LINENO "setting flag ARG_DONT_MAKE_PATHS"
            ;;
        --add-git-ignore)
            ARG_ADD_GITIGNORE=1
            log_trace $LINENO "setting flag ARG_ADD_GITIGNORE"
            ;;
        -t | --target)
            if [[ "${2}" =~ bin|cache|config|data|state|runtime ]]; then
                ARG_TGT="${2}"
                shift
            else
                log_error $LINENO "invalid target type, specified: ${2}"
                usage 1
            fi
            ;;
        *)
            if [[ -n "${ARG_CMD}" ]]; then
                ARG_SRC+=("${1}")
                log_trace $LINENO "sources: ${ARG_SRC[*]}"
            else
                log_error $LINENO "cannot treat ${1} as a source, no command specified"
                usage 1
            fi
            ;;
        esac
        shift
    done
    if [[ -z "${ARG_CMD}" ]]; then
        log_error $LINENO "missing command"
        usage 1
    fi
}

function dispatch_command {
    case ${ARG_CMD} in
        cd)
            command_set_pwd ${STOW_AWAY_REPOSITORY}
            ;;
        mk)
            if [[ ${#ARG_SRC[@]} -eq 0 ]]; then
                log_error $LINENO "the make command requires at least one source"
                usage 1
            fi
            log_trace $LINENO "calling command_make '${ARG_PKG}' '${ARG_TGT}' '${STOW_AWAY_REPOSITORY}' (${ARG_SRC[@]})"
            command_make "${ARG_PKG}" "${ARG_TGT}" "${STOW_AWAY_REPOSITORY}" ${ARG_SRC[@]}
            ;;
        mv)
            if [[ ${#ARG_SRC[@]} -eq 0 ]]; then
                log_error $LINENO "the move command requires at least one source"
                usage 1
            fi
            log_trace $LINENO "calling command_move '${ARG_PKG}' '${ARG_TGT}' '${STOW_AWAY_REPOSITORY}' (${ARG_SRC[@]})"
            command_move "${ARG_PKG}" "${ARG_TGT}" "${STOW_AWAY_REPOSITORY}" ${ARG_SRC[@]}
            ;;
    esac
}

function command_make_target_path {
    local package=$1; shift
    local target=$1; shift
    local repository=$1; shift

    case "${target}" in
    bin)
        target="local/bin"
        ;;
    cache|config)
        ;;
    data)
        target="local/share"
        ;;
    state)
        target="local/state"
        ;;
    runtime)
        target="local/var/run"
        ;;
    *)
        log_error "invalid target type, specified: ${target}"
        usage 1
        ;;
    esac
    
    local path="${repository}/${target}/${package}"
    if [[ ! -d "${path}" && $ARG_DONT_MAKE_PATHS -eq 0 ]]; then
        echo "mkdir -p ${path}"
    elif [[ ! -d "${path}" && $ARG_DONT_MAKE_PATHS -eq 1 ]]; then
        log_error $LINENO "target path ${path} does not exist"
        exit 2
    fi

    local path=$(realpath "${path}")
    echo "${path}/"
}

function command_move {
    local package=$1; shift
    local target=$1; shift
    local repository=$1; shift
    local sources=$@

    log_trace $LINENO "command_move package: '${package}', target: '${target}', repository: ${repository}, sources: (${sources[@]})"

    if [[ ${#sources[@]} -gt 1 && -z "${package}" ]]; then
        log_error $LINENO "$(usage_arg --package) must be specified if more than one source is provided"
        exit 2
    elif [[ ${#sources[@]} -eq 1 && -f "${sources[0]}" && -z "${package}" ]]; then
        log_error $LINENO "$(usage_arg --package) must be specified if source is a file"
        exit 2
        log_trace $LINENO "assuming source name '${sources[0]}' is also the package name"
        package=${sources[0]}
    fi

    local target_path=$(command_make_target_path "${package}" "${target}" "${repository}")
    log_trace $LINENO "target_path: ${target_path}"
    for src in ${sources[@]}; do
        local src_file=$(basename "${src}")
        local tgt_file="${src_file}"
        local src_path=$(realpath "${src}")

        if [[ "${src_file}" =~ ^\. && ${ARG_DOT_DROP} -eq 1 ]]; then
            tgt_file="${src_file#[.]}"
        elif [[ "${src_file}" =~ ^\. && ${ARG_DOT_PREFIX} -eq 1 ]]; then
            tgt_file="dot-${src_file#[.]}"
        fi

        log_trace $LINENO "mv ${src_path} ${target_path}${tgt_file}"
        mv "${src_path}" "${target_path}${tgt_file}"

        if [[ -d "${target_path}${tgt_file}" && ${ARG_ADD_GITIGNORE} -eq 1 ]]; then
            gitignore="${target_path}${tgt_file}/.gitignore"
            log_trace $LINENO "creating ${gitignore} in target directory"
            if [[ ! -f "${gitignore}" ]]; then
                cat <<EOF > "${gitignore}"
# Ignore everything in this directory, and sub-directories
**/*

# Except this file
!.gitignore
EOF
            else
                log_warning $LINENO "file ${gitignore} exists, skipping"
            fi
        fi

        log_trace $LINENO "ln -s ${target_path}${tgt_file} ${src_path}"
        ln -s "${target_path}${tgt_file}" "${src_path}"
    done
}

function command_make {
    local package=$1; shift
    local target=$1; shift
    local repository=$1; shift
    local sources=$@

    
}

function command_set_pwd {
    local repository=$1

    echo "cd ${repository}"
}

parse_cmdline $@

dispatch_command